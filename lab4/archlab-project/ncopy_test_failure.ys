
            .pos 0
            irmovq stack, %rsp
            irmovq data_to_copy, %rdi
            irmovq data_dst, %rsi
            irmovq $2, %rdx

            call ncopy
            halt
            nop
            nop
            nop
            nop
            nop
        
        ################################################################################
# ncopy.ys - Copy a src block of len words to dst.
# Return the number of positive words (>0) contained in src.
# 张庭瑞 2400017786
# - use unroll by 7
# - use iopq to save one instruction
# - use condigtional move to reduce penalty
# - use custom prediction to reduce misprediction penalty
################################################################################
# Do not modify this portion
# Function prologue.
# %rdi = src, %rsi = dst, %rdx = len
ncopy:
################################################################################
# You can modify this portion
	# xorq %rax, %rax        # count = 0
    # andq %rdx, %rdx
    # jle Done

Loop:
    # if less than 6 remain, jump to tail
    rrmovq %rdx, %r14
    isubq $6, %r14
    jl Tail

    # load (no use after load hazard)
    mrmovq 0(%rdi), %r8
    mrmovq 8(%rdi), %r9
    mrmovq 16(%rdi), %r10
    mrmovq 24(%rdi), %r11
    mrmovq 32(%rdi), %r12
    mrmovq 40(%rdi), %r13
    # mrmovq 48(%rdi), %r14

    # store 

    # update count
    rrmovq %rax, %rcx
    iaddq $1, %rcx
    rmmovq %r8, 0(%rsi)
    andq %r8, %r8
    cmovg %rcx, %rax

    rrmovq %rax, %rcx
    iaddq $1, %rcx
    rmmovq %r9, 8(%rsi)
    andq %r9, %r9
    cmovg %rcx, %rax

    rrmovq %rax, %rcx
    iaddq $1, %rcx
    rmmovq %r10, 16(%rsi)
    andq %r10, %r10
    cmovg %rcx, %rax

    rrmovq %rax, %rcx
    iaddq $1, %rcx
    rmmovq %r11, 24(%rsi)
    andq %r11, %r11
    cmovg %rcx, %rax

    rrmovq %rax, %rcx
    iaddq $1, %rcx
    rmmovq %r12, 32(%rsi)
    andq %r12, %r12
    cmovg %rcx, %rax

    rrmovq %rax, %rcx
    iaddq $1, %rcx
    rmmovq %r13, 40(%rsi)
    andq %r13, %r13
    cmovg %rcx, %rax

    # rrmovq %rax, %rcx
    # iaddq $1, %rcx
    # andq %r14, %r14
    # cmovg %rcx, %rax

    iaddq $48, %rdi
    iaddq $48, %rsi
    isubq $6, %rdx
    jne Loop

Tail:
    # handle left elements
    rrmovq %rdx, %r14
    isubq $2, %r14
    jl TailTail

    mrmovq (%rdi), %r10
    mrmovq 8(%rdi), %r11

    rrmovq %rax, %r12
    iaddq $1, %r12

    rmmovq %r10, (%rsi)
    rmmovq %r11, 8(%rsi)
    
    andq %r10, %r10
    cmovg %r12, %rax

    rrmovq %rax, %r12
    iaddq $1, %r12
    andq %r11, %r11
    cmovg %r12, %rax
    
    iaddq $16, %rsi
    iaddq $16, %rdi
    isubq $2, %rdx
    jne Tail

TailTail:
    andq %rdx, %rdx
    je Done
    # handle remaining single element (if len == 1)
    mrmovq (%rdi), %r10

    rrmovq %rax, %r11
    iaddq $1, %r11

    andq %r10, %r10
    cmovg %r11, %rax

    rmmovq %r10, (%rsi)

    iaddq $8, %rsi
    iaddq $8, %rdi
    isubq $1, %rdx

Done:
    ret

        # do not fall through to the end of the source!
        # Otherwise you will encounter this trap :)
        trapititit: jmp trapititit

            .pos 0x1000 # source code + stack limits to 4kb
            .align 8
        stack:
        data_to_copy:
            .quad 0x61da6f3dc380d507
.quad 0x5c0fdf91ec9a7bfc
        data_dst:
        